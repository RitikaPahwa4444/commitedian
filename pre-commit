#!/bin/bash

# Smart pre-commit hook leveraging GitHub Copilot CLI for AI-powered code review with playful feedback
# Ensure GitHub CLI and Copilot CLI extension are installed
# Add colorful output and graphics
GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[0;33m"
BLUE="\033[0;34m"
NC="\033[0m" # No Color

# Function to display a welcome banner
print_welcome_banner() {
  echo -e "${BLUE}====================================================================================${NC}"
  echo -e "${YELLOW}   ____    ____   __  __  __  __  _  ______  _   ____   _____   ______   _     _ ${NC}"
  echo -e "${YELLOW}  / ___|  / __ \ |  \/  ||  \/  || ||__  __|| | |  _ \ | ____| /  __  \ | \   | |${NC}"
  echo -e "${YELLOW} | |     | |  | || |\/| || |\/| || |   | |  | | | | | ||  _|   | |__| | | |\  | |${NC}"
  echo -e "${YELLOW} | |___  | |__| || |  | || |  | || |   | |  | | | |_| || |___  |  __  | | | \ | |${NC}"
  echo -e "${YELLOW}  \____|  \____/ |_|  |_||_|  |_||_|   |_|  |_| |____/ |_____| |_|  |_| |_|  \|_|${NC}"
  echo -e ""                                                    
  echo -e "${BLUE}====================================================================================${NC}"
  echo -e "${GREEN}                       ðŸŽ­ Welcome to Commitedian ðŸŽ­                                ${NC}"
  echo -e "${BLUE}====================================================================================${NC}"
}

# Function to display a success graphic
print_success_graphic() {
  echo -e "${BLUE} __     __  ______  __     __   _  ${NC}"
  echo -e "${BLUE}  \ \_/ /  /  __  \  \ \_/ /   | | ${NC}"
  echo -e "${BLUE}   \   /   | |__| |   \   /    |_| ${NC}"
  echo -e "${BLUE}    | |    |  __  |    | |      _  ${NC}"
  echo -e "${BLUE}    |_|    |_|  |_|    |_|     |_| ${NC}"
  echo -e ""                                                    
  echo -e "${GREEN}======= ðŸŽ‰ðŸŽ‰ðŸŽ‰ SUCCESS! ðŸŽ‰ðŸŽ‰ðŸŽ‰ ====== ${NC}"
  echo -e "${GREEN}Your code is clean and ready to commit!${NC}"
}

# Function to display a failure graphic
print_failure_graphic() {
  echo -e "${RED}             ____    ____   ____     ___     _  ${NC}"
  echo -e "${RED}            / __ \  / __ \ |  _ \ | |  |_|  | | ${NC}"
  echo -e "${RED}           | |  | || |  | || |_| |   \      |_| ${NC}"
  echo -e "${RED}           | |__| || |__| || __ /  _  \ _    _  ${NC}"
  echo -e "${RED}            \____/  \____/ |_|    | |__| |  |_| ${NC}"
  echo -e ""            
  echo -e "${YELLOW}============== ðŸ’¥ðŸ’¥ðŸ’¥ PLEASE TRY AGAIN! ðŸ’¥ðŸ’¥ðŸ’¥ ============== ${NC}"
  echo -e "${RED}Issues detected in your code. Please fix them before committing.${NC}"                                                  
}

print_welcome_banner
issues_found=false


# Check if jq is installed
if ! command -v jq &> /dev/null; then
  echo -e "${YELLOW}jq is not installed. Installing it for you...${NC}"
  if [[ "$OSTYPE" == "darwin"* ]]; then
    brew install jq
  else
    echo -e "${RED}Unsupported OS. Please install jq manually: https://stedolan.github.io/jq/download/${NC}"
    exit 1
  fi
  if [ $? -ne 0 ]; then
    echo -e "${RED}Failed to install jq. Please install it manually: https://stedolan.github.io/jq/download/${NC}"
    exit 1
  fi
  echo -e "${GREEN}jq installed successfully!${NC}"
else
  echo -e "${GREEN}jq is already installed.${NC}"
fi

# Install GitHub CLI if not present
if ! command -v gh &> /dev/null; then
  echo -e "${YELLOW}GitHub CLI not found. Installing it for you...${NC}"
  if [[ "$OSTYPE" == "darwin"* ]]; then
    brew install gh
  else
    echo -e "${RED}Unsupported OS. Please install GitHub CLI manually: https://cli.github.com/${NC}"
    exit 1
  fi
  if [ $? -ne 0 ]; then
    echo -e "${RED}Failed to install GitHub CLI. Please install it manually: https://cli.github.com/${NC}"
    exit 1
  fi
  echo -e "${GREEN}GitHub CLI installed successfully!${NC}"
fi

# Ensure GitHub CLI is authenticated
if ! gh auth status &> /dev/null; then
  echo -e "${YELLOW}You are not logged into GitHub CLI. Initiating login...${NC}"
  gh auth login
  if [ $? -ne 0 ]; then
    echo -e "${RED}Failed to authenticate with GitHub CLI. Please try again.${NC}"
    exit 1
  fi
  echo -e "${GREEN}Successfully authenticated with GitHub CLI!${NC}"
fi

# Install GH models extension if not present
if ! gh extension list | grep -q models; then
  echo -e "${YELLOW}GitHub Models extension not found. Installing it for you...${NC}"
  gh extension install github/gh-models
  if [ $? -ne 0 ]; then
    echo -e "${RED}Failed to install GitHub Models extension. Please install it manually: https://github.com/github/gh-models${NC}"
    exit 1
  fi
  echo -e "${GREEN}GitHub Models extension installed successfully!${NC}"
fi
# Ensure required sound files are available in the repository's `sounds` folder
repo_root=$(git rev-parse --show-toplevel)
sounds_dir="$repo_root/sounds"

sound_files=(
  "laugh.mp3"
  "thunderstorm.mp3"
  "applause.mp3"
  "boing.mp3"
  "silly_laugh.mp3"
)

declare -A issue_sounds=(
  ["debug_log"]="$sounds_dir/laugh.mp3"
  ["hard_coded_secret"]="$sounds_dir/thunderstorm.mp3"
  ["typo"]="$sounds_dir/silly_laugh.mp3"
  ["generic_name"]="$sounds_dir/boing.mp3"
)

for sound_file in "${sound_files[@]}"; do
  source_path="$sounds_dir/$sound_file"
  if [ ! -f "$source_path" ]; then
    echo -e "${RED}Sound file $sound_file not found in $sounds_dir. Please ensure it is present.${NC}"
    exit 1
  else
    echo -e "${GREEN}Sound file $sound_file found in $sounds_dir.${NC}"
  fi
done

echo -e "${GREEN}All sound files are available and ready!${NC}"

# Function to play sound and display a message
play_sound_and_message() {
  local sound_file=$1
  local message=$2

  if [ -f "$sound_file" ]; then
    if [[ "$OSTYPE" == "darwin"* ]]; then
      if command -v afplay &> /dev/null; then
        afplay "$sound_file" &
      else
        echo -e "${YELLOW}afplay is not installed. Skipping audio playback.${NC}"
      fi
    else
      echo -e "${YELLOW}Audio playback is not supported on this platform.${NC}"
    fi
  else
    echo -e "${RED}Sound file $sound_file not found. Skipping playback.${NC}"
  fi

  echo -e "${BLUE}$message${NC}"
}

# Function to handle issue types dynamically
handle_issue_type() {
  local issue_type=$1
  local file=$2
  local sound_file=$3
  local copilot_output=$4

  # Sanitize copilot_output by removing ```json and ``` markers
  copilot_output=$(echo "$copilot_output" | sed 's/^```json//' | sed 's/```$//')

  echo "$copilot_output"

  while IFS="|" read -r issue_type playful_message; do
    echo "Issue Found: $issue_type"
    sound_file="${issue_sounds[$issue_type]}"
    if [[ -n "$sound_file" ]]; then
        play_sound_and_message "$sound_file" "$playful_message"
    else
        echo -e "${YELLOW}No sound associated with issue type: $issue_type. Skipping playback.${NC}"
    fi
    issues_found=true
  done < <(echo "$copilot_output" | jq -r '.[] | "\(.issue_type)|\(.playful_message)"')

  if $issues_found; then
    print_failure_graphic
  else
    play_sound_and_message "$sounds_dir/applause.mp3" "Great job! No issues found in $file."
    print_success_graphic
  fi
}

prompt="Review this code diff for the following issues: 
    1. Weird debug logs (e.g., \"hello from ABC!\") or too many debug print statements (as if a debugger never existed). 
    2. Hard-coded secrets (e.g., passwords, API keys). 
    3. Typos or grammatical errors. 
    4. Generic variable or function names (e.g., temp, data). 
    5. Any other potential issues or improvements. 
    For each detected issue, provide a JSON response with fields: \"issue_type\" and \"playful_message\". The \"playful_message\" should be witty and engaging, tailored to the issue type and the code being reviewed.

    Classify the issues into the following issue_type:
        \"debug_log\"
        \"hard_coded_secret\"
        \"typo\"
        \"generic_name\"
    Only return valid json as output, no other text.
    Indicate the line of code (skip line number, point to actual code) and context of the issue in the playful message. Name the exact generic variable name used, typo made, grammatical error, or debug log message.
    CODE_DIFF: "

# Analyze all staged files
staged_files=$(git diff --cached --name-only)

if [ -z "$staged_files" ]; then
  echo -e "${YELLOW}No files staged for commit. Skipping analysis.${NC}"
  exit 0
fi

batch_size=5
file_batch=()

process_batch() {
  for file in "${file_batch[@]}"; do
    if [ -f "$file" ]; then
      echo -e "${BLUE}Running GitHub review on $file...${NC}"
      git_diff=$(git diff --cached "$file")
      if [ -z "$git_diff" ]; then
        echo -e "${YELLOW}No changes detected in $file. Skipping analysis.${NC}"
        continue
      fi
      echo -e "${BLUE}Code diff for $file:\n$git_diff${NC}"
      final_prompt="$prompt\n$git_diff"
      copilot_output=$(gh models run openai/gpt-4o-mini "$final_prompt")
      
      for issue_type in "${!issue_sounds[@]}"; do
        handle_issue_type "$issue_type" "$file" "${issue_sounds[$issue_type]}" "$copilot_output"
      done
    fi
  done
}

for file in $staged_files; do
  file_batch+=("$file")
  if [ "${#file_batch[@]}" -ge "$batch_size" ]; then
    process_batch
    file_batch=()
  fi
done

if [ "${#file_batch[@]}" -gt 0 ]; then
  process_batch
fi

echo -e "${YELLOW}Do you want to proceed with the commit? (yes/no)${NC}"

read -r user_input < /dev/tty

if [[ "$user_input" == "yes" ]]; then
  echo -e "${GREEN}Proceeding with the commit...${NC}"
  exit 0
else
  echo -e "${RED}Commit aborted by the user.${NC}"
  exit 1
fi
